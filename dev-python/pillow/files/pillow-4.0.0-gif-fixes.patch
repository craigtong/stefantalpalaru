From 44241cdec5948c4d4d2467b03b8de1bd68c8b195 Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Thu, 26 Jan 2017 13:51:20 +1100
Subject: [PATCH 01/26] Added _save_netpbm comment

---
 PIL/GifImagePlugin.py | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 7fe662f..2c36864 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -32,10 +32,6 @@
 
 
 # --------------------------------------------------------------------
-# Helpers
-
-
-# --------------------------------------------------------------------
 # Identify/read GIF files
 
 def _accept(prefix):
@@ -501,6 +497,8 @@ def _get_local_header(fp, im, offset, flags):
 
 def _save_netpbm(im, fp, filename):
 
+    # Unused by default.
+    # To use, uncomment the register_save call at the end of the file.
     #
     # If you need real GIF compression and/or RGB quantization, you
     # can use the external NETPBM/PBMPLUS utilities.  See comments

From 72506a6e73f7029b14e115a03f16195d6238d757 Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Wed, 28 Dec 2016 09:48:16 +1100
Subject: [PATCH 02/26] Minor code cleanup in GifImagePlugin

---
 PIL/GifImagePlugin.py | 15 +++++----------
 1 file changed, 5 insertions(+), 10 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 2c36864..8bba4d0 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -434,13 +434,10 @@ def _get_local_header(fp, im, offset, flags):
         used_palette_colors = _get_optimize(im, im.encoderinfo)
         if used_palette_colors is not None:
             # adjust the transparency index after optimize
-            for i, palette_color in enumerate(used_palette_colors):
-                if palette_color == transparency:
-                    transparency = i
-                    transparent_color_exists = True
-                    break
-                else:
-                    transparent_color_exists = False
+            try:
+                transparency = used_palette_colors.index(transparency)
+            except ValueError:
+                transparent_color_exists = False
 
     if "duration" in im.encoderinfo:
         duration = int(im.encoderinfo["duration"] / 10)
@@ -570,11 +567,9 @@ def _get_used_palette_colors(im):
     used_palette_colors = []
 
     # check which colors are used
-    i = 0
-    for count in im.histogram():
+    for i, count in enumerate(im.histogram()):
         if count:
             used_palette_colors.append(i)
-        i += 1
 
     return used_palette_colors
 

From 13359d8b9a3281f62b8a92387968852eda12c7e0 Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Thu, 26 Jan 2017 15:27:43 +1100
Subject: [PATCH 03/26] Only call _get_used_palette_colors when necessary

---
 PIL/GifImagePlugin.py | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 8bba4d0..11939ca 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -556,12 +556,12 @@ def _get_optimize(im, info):
         # * If we have a 'large' image, the palette is in the noise.
 
         # create the new palette if not every color is used
-        used_palette_colors = _get_used_palette_colors(im)
-        if _FORCE_OPTIMIZE or im.mode == 'L' or \
-           (len(used_palette_colors) <= 128 and
-            max(used_palette_colors) > len(used_palette_colors) and
-            im.width * im.height < 512 * 512):
-            return used_palette_colors
+        optimise = _FORCE_OPTIMIZE or im.mode == 'L'
+        if optimise or im.width * im.height < 512 * 512:
+            used_palette_colors = _get_used_palette_colors(im)
+            if optimise or (len(used_palette_colors) <= 128 and
+                max(used_palette_colors) > len(used_palette_colors)):
+                return used_palette_colors
 
 def _get_used_palette_colors(im):
     used_palette_colors = []

From 86971a7a94b275d35573052c570749cf2e66b7bc Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Thu, 26 Jan 2017 14:17:20 +1100
Subject: [PATCH 04/26] Merged _get_used_palette_colors into _get_optimize

---
 PIL/GifImagePlugin.py | 17 ++++++-----------
 1 file changed, 6 insertions(+), 11 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 11939ca..da24123 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -558,21 +558,16 @@ def _get_optimize(im, info):
         # create the new palette if not every color is used
         optimise = _FORCE_OPTIMIZE or im.mode == 'L'
         if optimise or im.width * im.height < 512 * 512:
-            used_palette_colors = _get_used_palette_colors(im)
+            # check which colors are used
+            used_palette_colors = []
+            for i, count in enumerate(im.histogram()):
+                if count:
+                    used_palette_colors.append(i)
+
             if optimise or (len(used_palette_colors) <= 128 and
                 max(used_palette_colors) > len(used_palette_colors)):
                 return used_palette_colors
 
-def _get_used_palette_colors(im):
-    used_palette_colors = []
-
-    # check which colors are used
-    for i, count in enumerate(im.histogram()):
-        if count:
-            used_palette_colors.append(i)
-
-    return used_palette_colors
-
 def _get_color_table_size(palette_bytes):
     # calculate the palette size for the header
     import math

From 90d55b8e317e086c7993e0fe0cbb5f9e987383da Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Thu, 29 Dec 2016 10:23:43 +1100
Subject: [PATCH 05/26] Removed unnecessary copy operation

---
 PIL/GifImagePlugin.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index da24123..d4c6a64 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -370,7 +370,7 @@ def _save(im, fp, filename, save_all=False):
                         first_frame = None
 
                     # delta frame
-                    delta = ImageChops.subtract_modulo(im_frame, previous.copy())
+                    delta = ImageChops.subtract_modulo(im_frame, previous)
                     bbox = delta.getbbox()
 
                     if bbox:

From e820936ef9e17a3b32c92d9363f25b31e511d23d Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Thu, 29 Dec 2016 11:04:41 +1100
Subject: [PATCH 06/26] Resolved GifImagePlugin FIXME

---
 PIL/GifImagePlugin.py | 69 ++++++++++++++++++++++++++++-----------------------
 1 file changed, 38 insertions(+), 31 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index d4c6a64..fd834a0 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -340,51 +340,58 @@ def _save(im, fp, filename, save_all=False):
         im.encoderinfo["optimize"] = im.encoderinfo.get("optimize", True)
 
     if save_all:
-        previous = None
-
-        first_frame = None
-        append_images = im.encoderinfo.get("append_images", [])
+        # To specify duration, add the time in milliseconds to getdata(),
+        # e.g. getdata(im_frame, duration=1000)
         if "duration" in im.encoderinfo:
             duration = im.encoderinfo["duration"]
         else:
             duration = None
+        im_frames = []
+        append_images = im.encoderinfo.get("append_images", [])
         frame_count = 0
         for imSequence in [im]+append_images:
             for im_frame in ImageSequence.Iterator(imSequence):
-                encoderinfo = im.encoderinfo.copy()
                 im_frame = _convert_mode(im_frame)
+
+                encoderinfo = im.encoderinfo.copy()
                 if isinstance(duration, (list, tuple)):
-                    encoderinfo["duration"] = duration[frame_count]
+                    encoderinfo['duration'] = duration[frame_count]
                 frame_count += 1
 
-                # To specify duration, add the time in milliseconds to getdata(),
-                # e.g. getdata(im_frame, duration=1000)
-                if not previous:
-                    # global header
-                    first_frame = getheader(im_frame, palette, encoderinfo)[0]
-                    first_frame += getdata(im_frame, (0, 0), **encoderinfo)
-                else:
-                    if first_frame:
-                        for s in first_frame:
-                            fp.write(s)
-                        first_frame = None
-
+                if im_frames:
                     # delta frame
-                    delta = ImageChops.subtract_modulo(im_frame, previous)
+                    previous = im_frames[-1]
+                    delta = ImageChops.subtract_modulo(im_frame,
+                                                       previous['im_frame'])
                     bbox = delta.getbbox()
-
-                    if bbox:
-                        # compress difference
-                        encoderinfo['include_color_table'] = True
-                        for s in getdata(im_frame.crop(bbox),
-                                         bbox[:2], **encoderinfo):
-                            fp.write(s)
-                    else:
-                        # FIXME: what should we do in this case?
-                        pass
-                previous = im_frame
-        if first_frame:
+                    if not bbox:
+                        # This frame is identical to the previous frame
+                        if duration:
+                            previous['encoderinfo']['duration'] += encoderinfo['duration']
+                        continue
+                else:
+                    bbox = None
+                im_frames.append({
+                    "im_frame":im_frame,
+                    "bbox":bbox,
+                    "encoderinfo":encoderinfo
+                })
+        if len(im_frames) < 2:
             save_all = False
+        else:
+            for data in im_frames:
+                if data['bbox'] is None:
+                    # global header
+                    header = getheader(data['im_frame'], palette, data['encoderinfo'])[0]
+                    for s in header + getdata(data['im_frame'],
+                                              (0, 0), **data['encoderinfo']):
+                        fp.write(s)
+                else:
+                    # compress difference
+                    data['encoderinfo']['include_color_table'] = True
+                    for s in getdata(data['im_frame'].crop(data['bbox']),
+                                     data['bbox'][:2], **data['encoderinfo']):
+                        fp.write(s)
     if not save_all:
         header = getheader(im_out, palette, im.encoderinfo)[0]
         for s in header:

From f5523eadedd50bcaf8fe253742de91b313b1c689 Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Thu, 29 Dec 2016 11:28:58 +1100
Subject: [PATCH 07/26] Added test

---
 Tests/test_file_gif.py | 28 ++++++++++++++++++++++++++--
 1 file changed, 26 insertions(+), 2 deletions(-)

diff --git a/Tests/test_file_gif.py b/Tests/test_file_gif.py
index d987f68..df17efe 100644
--- a/Tests/test_file_gif.py
+++ b/Tests/test_file_gif.py
@@ -287,7 +287,7 @@ def test_multiple_duration(self):
         im_list = [
             Image.new('L', (100, 100), '#000'),
             Image.new('L', (100, 100), '#111'),
-            Image.new('L', (100, 100), '#222'),
+            Image.new('L', (100, 100), '#222')
         ]
 
         #duration as list
@@ -322,7 +322,31 @@ def test_multiple_duration(self):
             except EOFError:
                 pass
 
+    def test_identical_frames(self):
+        duration_list = [1000, 1500, 2000, 4000]
 
+        out = self.tempfile('temp.gif')
+        im_list = [
+            Image.new('L', (100, 100), '#000'),
+            Image.new('L', (100, 100), '#000'),
+            Image.new('L', (100, 100), '#000'),
+            Image.new('L', (100, 100), '#111')
+        ]
+
+        #duration as list
+        im_list[0].save(
+            out,
+            save_all=True,
+            append_images=im_list[1:],
+            duration=duration_list
+        )
+        reread = Image.open(out)
+
+        # Assert that the first three frames were combined
+        self.assertEqual(reread.n_frames, 2)
+
+        # Assert that the new duration is the total of the identical frames
+        self.assertEqual(reread.info['duration'], 4500)
 
     def test_number_of_loops(self):
         number_of_loops = 2
@@ -425,7 +449,7 @@ def test_transparent_optimize(self):
         reloaded = Image.open(out)
 
         self.assertEqual(reloaded.info['transparency'], 253)
-        
+
 
 if __name__ == '__main__':
     unittest.main()

From 45abb757e006e0d9814a30c1676bc40abe651455 Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Sat, 28 Jan 2017 11:45:59 +1100
Subject: [PATCH 08/26] Simplified code

---
 PIL/GifImagePlugin.py  | 38 ++++++++++++++++++--------------------
 Tests/test_file_gif.py | 14 ++++----------
 2 files changed, 22 insertions(+), 30 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index fd834a0..455c262 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -294,7 +294,7 @@ def load_end(self):
 RAWMODE = {
     "1": "L",
     "L": "L",
-    "P": "P",
+    "P": "P"
 }
 
 
@@ -317,7 +317,6 @@ def _save_all(im, fp, filename):
 
 
 def _save(im, fp, filename, save_all=False):
-
     im.encoderinfo.update(im.info)
     if _imaging_gif:
         # call external driver
@@ -362,7 +361,7 @@ def _save(im, fp, filename, save_all=False):
                     # delta frame
                     previous = im_frames[-1]
                     delta = ImageChops.subtract_modulo(im_frame,
-                                                       previous['im_frame'])
+                                                       previous['im'])
                     bbox = delta.getbbox()
                     if not bbox:
                         # This frame is identical to the previous frame
@@ -372,37 +371,36 @@ def _save(im, fp, filename, save_all=False):
                 else:
                     bbox = None
                 im_frames.append({
-                    "im_frame":im_frame,
-                    "bbox":bbox,
-                    "encoderinfo":encoderinfo
+                    'im':im_frame,
+                    'bbox':bbox,
+                    'encoderinfo':encoderinfo
                 })
         if len(im_frames) < 2:
             save_all = False
         else:
-            for data in im_frames:
-                if data['bbox'] is None:
+            for frame_data in im_frames:
+                im_frame = frame_data['im']
+                if not frame_data['bbox']:
                     # global header
-                    header = getheader(data['im_frame'], palette, data['encoderinfo'])[0]
-                    for s in header + getdata(data['im_frame'],
-                                              (0, 0), **data['encoderinfo']):
+                    for s in getheader(im_frame, palette, frame_data['encoderinfo'])[0]:
                         fp.write(s)
+                    offset = (0, 0)
                 else:
                     # compress difference
-                    data['encoderinfo']['include_color_table'] = True
-                    for s in getdata(data['im_frame'].crop(data['bbox']),
-                                     data['bbox'][:2], **data['encoderinfo']):
-                        fp.write(s)
+                    frame_data['encoderinfo']['include_color_table'] = True
+
+                    im_frame = im_frame.crop(frame_data['bbox'])
+                    offset = frame_data['bbox'][:2]
+                for s in getdata(im_frame, offset, **frame_data['encoderinfo']):
+                    fp.write(s)
     if not save_all:
-        header = getheader(im_out, palette, im.encoderinfo)[0]
-        for s in header:
+        for s in getheader(im_out, palette, im.encoderinfo)[0]:
             fp.write(s)
 
+        # local image header
         flags = 0
-
         if get_interlace(im):
             flags = flags | 64
-
-        # local image header
         _get_local_header(fp, im, (0, 0), flags)
 
         im_out.encoderconfig = (8, get_interlace(im))
diff --git a/Tests/test_file_gif.py b/Tests/test_file_gif.py
index df17efe..5db3820 100644
--- a/Tests/test_file_gif.py
+++ b/Tests/test_file_gif.py
@@ -271,11 +271,8 @@ def test_duration(self):
         duration = 1000
 
         out = self.tempfile('temp.gif')
-        with open(out, "wb") as fp:
-            im = Image.new('L', (100, 100), '#000')
-            for s in GifImagePlugin.getheader(im)[0] + GifImagePlugin.getdata(im, duration=duration):
-                fp.write(s)
-            fp.write(b";")
+        im = Image.new('L', (100, 100), '#000')
+        im.save(out, duration=duration)
         reread = Image.open(out)
 
         self.assertEqual(reread.info['duration'], duration)
@@ -352,11 +349,8 @@ def test_number_of_loops(self):
         number_of_loops = 2
 
         out = self.tempfile('temp.gif')
-        with open(out, "wb") as fp:
-            im = Image.new('L', (100, 100), '#000')
-            for s in GifImagePlugin.getheader(im)[0] + GifImagePlugin.getdata(im, loop=number_of_loops):
-                fp.write(s)
-            fp.write(b";")
+        im = Image.new('L', (100, 100), '#000')
+        im.save(out, loop=number_of_loops)
         reread = Image.open(out)
 
         self.assertEqual(reread.info['loop'], number_of_loops)

From cf1c5127628fd7be389bff57938c2dbf0ed1fedf Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Sat, 18 Feb 2017 19:09:10 +1100
Subject: [PATCH 09/26] Extracted core of getdata into _write_frame_data

---
 PIL/GifImagePlugin.py | 29 +++++++++++++++--------------
 1 file changed, 15 insertions(+), 14 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 455c262..39ec5a1 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -391,8 +391,7 @@ def _save(im, fp, filename, save_all=False):
 
                     im_frame = im_frame.crop(frame_data['bbox'])
                     offset = frame_data['bbox'][:2]
-                for s in getdata(im_frame, offset, **frame_data['encoderinfo']):
-                    fp.write(s)
+                _write_frame_data(fp, im_frame, offset, frame_data['encoderinfo'])
     if not save_all:
         for s in getheader(im_out, palette, im.encoderinfo)[0]:
             fp.write(s)
@@ -715,6 +714,19 @@ def getheader(im, palette=None, info=None):
     header.append(_get_header_palette(palette_bytes))
     return header, used_palette_colors
 
+def _write_frame_data(fp, im_frame, offset, params):
+    try:
+        im_frame.encoderinfo = params
+
+        # local image header
+        _get_local_header(fp, im_frame, offset, 0)
+
+        ImageFile._save(im_frame, fp, [("gif", (0, 0)+im_frame.size, 0,
+                                        RAWMODE[im_frame.mode])])
+
+        fp.write(b"\0")  # end of image data
+    finally:
+        del im_frame.encoderinfo
 
 def getdata(im, offset=(0, 0), **params):
     """Return a list of strings representing this image.
@@ -731,18 +743,7 @@ def write(self, data):
 
     fp = Collector()
 
-    try:
-        im.encoderinfo = params
-
-        # local image header
-        _get_local_header(fp, im, offset, 0)
-
-        ImageFile._save(im, fp, [("gif", (0, 0)+im.size, 0, RAWMODE[im.mode])])
-
-        fp.write(b"\0")  # end of image data
-
-    finally:
-        del im.encoderinfo
+    _write_frame_data(fp, im, offset, params)
 
     return fp.data
 

From 7797aff3bb84d3cc06a86e2c008a24219d0b3f9e Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Sat, 18 Feb 2017 19:02:52 +1100
Subject: [PATCH 10/26] Extracted core of getheader into _get_global_header

---
 PIL/GifImagePlugin.py | 55 ++++++++++++++++++++++++++-------------------------
 1 file changed, 28 insertions(+), 27 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 39ec5a1..897291b 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -382,7 +382,8 @@ def _save(im, fp, filename, save_all=False):
                 im_frame = frame_data['im']
                 if not frame_data['bbox']:
                     # global header
-                    for s in getheader(im_frame, palette, frame_data['encoderinfo'])[0]:
+                    for s in _get_global_header(im_frame, palette,
+                                                frame_data['encoderinfo']):
                         fp.write(s)
                     offset = (0, 0)
                 else:
@@ -393,7 +394,7 @@ def _save(im, fp, filename, save_all=False):
                     offset = frame_data['bbox'][:2]
                 _write_frame_data(fp, im_frame, offset, frame_data['encoderinfo'])
     if not save_all:
-        for s in getheader(im_out, palette, im.encoderinfo)[0]:
+        for s in _get_global_header(im_out, palette, im.encoderinfo):
             fp.write(s)
 
         # local image header
@@ -666,7 +667,7 @@ def _get_palette_bytes(im, palette, info):
     # returning palette, _not_ padded to 768 bytes like our internal ones.
     return palette_bytes, used_palette_colors
 
-def getheader(im, palette=None, info=None):
+def _get_global_header(im, palette, info):
     """Return a list of strings representing a GIF header"""
 
     # Header Block
@@ -684,34 +685,34 @@ def getheader(im, palette=None, info=None):
         if im.info.get("version") == b"89a":
             version = b"89a"
 
-    header = [
-        b"GIF"+version +        # signature + version
-        o16(im.size[0]) +       # canvas width
-        o16(im.size[1])         # canvas height
+    palette_bytes = _get_palette_bytes(im, palette, info)[0]
+    color_table_size = _get_color_table_size(palette_bytes)
+
+    background = info["background"] if "background" in info else 0
+
+    return [
+        b"GIF"+version +               # signature + version
+        o16(im.size[0]) +              # canvas width
+        o16(im.size[1]) +              # canvas height
+
+        # Logical Screen Descriptor
+        # size of global color table + global color table flag
+        o8(color_table_size + 128) +  # packed fields
+        # background + reserved/aspect
+        o8(background) + o8(0) +
+
+        # Global Color Table
+        _get_header_palette(palette_bytes)
     ]
 
-    palette_bytes, used_palette_colors = _get_palette_bytes(im, palette, info)
+def getheader(im, palette=None, info=[]):
+    used_palette_colors = _get_optimize(im, info)
 
-    # Logical Screen Descriptor
-    color_table_size = _get_color_table_size(palette_bytes)
-    # size of global color table + global color table flag
-    header.append(o8(color_table_size + 128))  # packed fields
-    # background + reserved/aspect
-    if info and "background" in info:
-        background = info["background"]
-    elif "background" in im.info:
-        # This elif is redundant within GifImagePlugin
-        # since im.info parameters are bundled into the info dictionary
-        # However, external scripts may call getheader directly
-        # So this maintains earlier behaviour
-        background = im.info["background"]
-    else:
-        background = 0
-    header.append(o8(background) + o8(0))
-    # end of Logical Screen Descriptor
+    if not "background" in info and "background" in im.info:
+        info["background"] = im.info["background"]
+
+    header = _get_global_header(im, palette, info)
 
-    # Header + Logical Screen Descriptor + Global Color Table
-    header.append(_get_header_palette(palette_bytes))
     return header, used_palette_colors
 
 def _write_frame_data(fp, im_frame, offset, params):

From caa9c260f62eb1a9b268cb8ee7a2a13e28911fb2 Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Sat, 18 Feb 2017 19:03:44 +1100
Subject: [PATCH 11/26] Removed second return value from _get_palette_bytes

---
 PIL/GifImagePlugin.py | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 897291b..ed6d1f9 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -480,7 +480,7 @@ def _get_local_header(fp, im, offset, flags):
     include_color_table = im.encoderinfo.get('include_color_table')
     if include_color_table:
         palette = im.encoderinfo.get("palette", None)
-        palette_bytes = _get_palette_bytes(im, palette, im.encoderinfo)[0]
+        palette_bytes = _get_palette_bytes(im, palette, im.encoderinfo)
         color_table_size = _get_color_table_size(palette_bytes)
         if color_table_size:
             flags = flags | 128               # local color table flag
@@ -665,7 +665,7 @@ def _get_palette_bytes(im, palette, info):
         palette_bytes = source_palette
 
     # returning palette, _not_ padded to 768 bytes like our internal ones.
-    return palette_bytes, used_palette_colors
+    return palette_bytes
 
 def _get_global_header(im, palette, info):
     """Return a list of strings representing a GIF header"""
@@ -685,7 +685,7 @@ def _get_global_header(im, palette, info):
         if im.info.get("version") == b"89a":
             version = b"89a"
 
-    palette_bytes = _get_palette_bytes(im, palette, info)[0]
+    palette_bytes = _get_palette_bytes(im, palette, info)
     color_table_size = _get_color_table_size(palette_bytes)
 
     background = info["background"] if "background" in info else 0

From 50e4a2a3fff18b919c05c878a2bcecbc6911eab4 Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Sat, 18 Feb 2017 21:23:42 +1100
Subject: [PATCH 12/26] Created _write_single_frame and _write_multiple_frames
 from _save

---
 PIL/GifImagePlugin.py | 152 +++++++++++++++++++++++++-------------------------
 1 file changed, 77 insertions(+), 75 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index ed6d1f9..abc95fc 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -311,6 +311,79 @@ def _convert_mode(im, initial_call=False):
             return im.convert("P")
     return im.convert("L")
 
+def _write_single_frame(im, fp, palette):
+    if im.mode in RAWMODE:
+        im_out = im.copy()
+    else:
+        im_out = _convert_mode(im, True)
+
+    for s in _get_global_header(im_out, palette, im.encoderinfo):
+        fp.write(s)
+
+    # local image header
+    flags = 0
+    if get_interlace(im):
+        flags = flags | 64
+    _get_local_header(fp, im, (0, 0), flags)
+
+    im_out.encoderconfig = (8, get_interlace(im))
+    ImageFile._save(im_out, fp, [("gif", (0, 0)+im.size, 0,
+                                  RAWMODE[im_out.mode])])
+
+    fp.write(b"\0")  # end of image data
+
+def _write_multiple_frames(im, fp, palette):
+    if "duration" in im.encoderinfo:
+        duration = im.encoderinfo["duration"]
+    else:
+        duration = None
+
+    im_frames = []
+    frame_count = 0
+    for imSequence in [im]+im.encoderinfo.get("append_images", []):
+        for im_frame in ImageSequence.Iterator(imSequence):
+            im_frame = _convert_mode(im_frame)
+
+            encoderinfo = im.encoderinfo.copy()
+            if isinstance(duration, (list, tuple)):
+                encoderinfo['duration'] = duration[frame_count]
+            frame_count += 1
+
+            if im_frames:
+                # delta frame
+                previous = im_frames[-1]
+                delta = ImageChops.subtract_modulo(im_frame,
+                                                   previous['im'])
+                bbox = delta.getbbox()
+                if not bbox:
+                    # This frame is identical to the previous frame
+                    if duration:
+                        previous['encoderinfo']['duration'] += encoderinfo['duration']
+                    continue
+            else:
+                bbox = None
+            im_frames.append({
+                'im':im_frame,
+                'bbox':bbox,
+                'encoderinfo':encoderinfo
+            })
+    if len(im_frames) > 1:
+        for frame_data in im_frames:
+            im_frame = frame_data['im']
+            if not frame_data['bbox']:
+                # global header
+                for s in _get_global_header(im_frame, palette,
+                                            frame_data['encoderinfo']):
+                    fp.write(s)
+                offset = (0, 0)
+            else:
+                # compress difference
+                frame_data['encoderinfo']['include_color_table'] = True
+
+                im_frame = im_frame.crop(frame_data['bbox'])
+                offset = frame_data['bbox'][:2]
+            _write_frame_data(fp, im_frame, offset, frame_data['encoderinfo'])
+        return True
 
 def _save_all(im, fp, filename):
     _save(im, fp, filename, save_all=True)
@@ -326,11 +399,6 @@ def _save(im, fp, filename, save_all=False):
         except IOError:
             pass  # write uncompressed file
 
-    if im.mode in RAWMODE:
-        im_out = im.copy()
-    else:
-        im_out = _convert_mode(im, True)
-
     # header
     try:
         palette = im.encoderinfo["palette"]
@@ -338,76 +406,8 @@ def _save(im, fp, filename, save_all=False):
         palette = None
         im.encoderinfo["optimize"] = im.encoderinfo.get("optimize", True)
 
-    if save_all:
-        # To specify duration, add the time in milliseconds to getdata(),
-        # e.g. getdata(im_frame, duration=1000)
-        if "duration" in im.encoderinfo:
-            duration = im.encoderinfo["duration"]
-        else:
-            duration = None
-        im_frames = []
-        append_images = im.encoderinfo.get("append_images", [])
-        frame_count = 0
-        for imSequence in [im]+append_images:
-            for im_frame in ImageSequence.Iterator(imSequence):
-                im_frame = _convert_mode(im_frame)
-
-                encoderinfo = im.encoderinfo.copy()
-                if isinstance(duration, (list, tuple)):
-                    encoderinfo['duration'] = duration[frame_count]
-                frame_count += 1
-
-                if im_frames:
-                    # delta frame
-                    previous = im_frames[-1]
-                    delta = ImageChops.subtract_modulo(im_frame,
-                                                       previous['im'])
-                    bbox = delta.getbbox()
-                    if not bbox:
-                        # This frame is identical to the previous frame
-                        if duration:
-                            previous['encoderinfo']['duration'] += encoderinfo['duration']
-                        continue
-                else:
-                    bbox = None
-                im_frames.append({
-                    'im':im_frame,
-                    'bbox':bbox,
-                    'encoderinfo':encoderinfo
-                })
-        if len(im_frames) < 2:
-            save_all = False
-        else:
-            for frame_data in im_frames:
-                im_frame = frame_data['im']
-                if not frame_data['bbox']:
-                    # global header
-                    for s in _get_global_header(im_frame, palette,
-                                                frame_data['encoderinfo']):
-                        fp.write(s)
-                    offset = (0, 0)
-                else:
-                    # compress difference
-                    frame_data['encoderinfo']['include_color_table'] = True
-
-                    im_frame = im_frame.crop(frame_data['bbox'])
-                    offset = frame_data['bbox'][:2]
-                _write_frame_data(fp, im_frame, offset, frame_data['encoderinfo'])
-    if not save_all:
-        for s in _get_global_header(im_out, palette, im.encoderinfo):
-            fp.write(s)
-
-        # local image header
-        flags = 0
-        if get_interlace(im):
-            flags = flags | 64
-        _get_local_header(fp, im, (0, 0), flags)
-
-        im_out.encoderconfig = (8, get_interlace(im))
-        ImageFile._save(im_out, fp, [("gif", (0, 0)+im.size, 0,
-                                      RAWMODE[im_out.mode])])
-
-        fp.write(b"\0")  # end of image data
+    if not save_all or not _write_multiple_frames(im, fp, palette):
+        _write_single_frame(im, fp, palette)
 
     fp.write(b";")  # end of file
 
@@ -729,6 +729,8 @@ def _write_frame_data(fp, im_frame, offset, params):
     finally:
         del im_frame.encoderinfo
 
+# To specify duration, add the time in milliseconds to getdata(),
+# e.g. getdata(im_frame, duration=1000)
 def getdata(im, offset=(0, 0), **params):
     """Return a list of strings representing this image.
        The first string is a local image header, the rest contains

From 73c091b6f86ec8657ff5344127bba60be21af3e9 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 03:25:05 -0800
Subject: [PATCH 13/26] Remove support for PIL plus external encoder

---
 PIL/GifImagePlugin.py | 12 ------------
 1 file changed, 12 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index abc95fc..9857036 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -286,11 +286,6 @@ def load_end(self):
 # --------------------------------------------------------------------
 # Write GIF files
 
-try:
-    import _imaging_gif
-except ImportError:
-    _imaging_gif = None
-
 RAWMODE = {
     "1": "L",
     "L": "L",
@@ -391,13 +386,6 @@ def _save_all(im, fp, filename):
 
 def _save(im, fp, filename, save_all=False):
     im.encoderinfo.update(im.info)
-    if _imaging_gif:
-        # call external driver
-        try:
-            _imaging_gif.save(im, fp, filename)
-            return
-        except IOError:
-            pass  # write uncompressed file
 
     # header
     try:

From d9614cc3c596fbbb5b2b71a13925f004d7850606 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 04:25:04 -0800
Subject: [PATCH 14/26] Refactor out the palette remapping to Image.Image

---
 PIL/GifImagePlugin.py | 79 +++++++++++++++++----------------------------------
 PIL/Image.py          | 77 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 103 insertions(+), 53 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 9857036..f774ace 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -538,6 +538,16 @@ def _save_netpbm(im, fp, filename):
 _FORCE_OPTIMIZE = False
 
 def _get_optimize(im, info):
+    """
+    Palette optimization is a potentially expensive operation.
+    
+    This function determines if the palette should be optimized using
+    some heuristics, then returns the list of palette entries in use.
+    
+    :param im: Image object
+    :param info: encoderinfo 
+    :returns: list of indexes of palette entries in use, or None
+    """
     if im.mode in ("P", "L") and info and info.get("optimize", 0):
         # Potentially expensive operation.
 
@@ -580,6 +590,16 @@ def _get_header_palette(palette_bytes):
     return palette_bytes
 
 def _get_palette_bytes(im, palette, info):
+    """
+    Gets the palette for inclusion in the gif header, if optimization is
+    requested or required, the palette is rewritten and the image is
+    mutatated in place. 
+    
+    :param im: Image object
+    :param palette: bytes object containing the source palette, or ....
+    :param info: encoderinfo 
+    :returns: Bytes, len<=768 suitable for inclusion in gif header
+    """
     if im.mode == "P":
         if palette and isinstance(palette, bytes):
             source_palette = palette[:768]
@@ -595,61 +615,14 @@ def _get_palette_bytes(im, palette, info):
 
     used_palette_colors = _get_optimize(im, info)
     if used_palette_colors is not None:
-        palette_bytes = b""
-        new_positions = [0]*256
-
-        # pick only the used colors from the palette
-        for i, oldPosition in enumerate(used_palette_colors):
-            palette_bytes += source_palette[oldPosition*3:oldPosition*3+3]
-            new_positions[oldPosition] = i
-
-        # replace the palette color id of all pixel with the new id
-
-        # Palette images are [0..255], mapped through a 1 or 3
-        # byte/color map.  We need to remap the whole image
-        # from palette 1 to palette 2. New_positions is
-        # an array of indexes into palette 1.  Palette 2 is
-        # palette 1 with any holes removed.
-
-        # We're going to leverage the convert mechanism to use the
-        # C code to remap the image from palette 1 to palette 2,
-        # by forcing the source image into 'L' mode and adding a
-        # mapping 'L' mode palette, then converting back to 'L'
-        # sans palette thus converting the image bytes, then
-        # assigning the optimized RGB palette.
-
-        # perf reference, 9500x4000 gif, w/~135 colors
-        # 14 sec prepatch, 1 sec postpatch with optimization forced.
-
-        mapping_palette = bytearray(new_positions)
-
-        m_im = im.copy()
-        m_im.mode = 'P'
-
-        m_im.palette = ImagePalette.ImagePalette("RGB",
-                                               palette=mapping_palette*3,
-                                               size=768)
-        #possibly set palette dirty, then
-        #m_im.putpalette(mapping_palette, 'L')  # converts to 'P'
-        # or just force it.
-        # UNDONE -- this is part of the general issue with palettes
-        m_im.im.putpalette(*m_im.palette.getdata())
-
-        m_im = m_im.convert('L')
-
-        # Internally, we require 768 bytes for a palette.
-        new_palette_bytes = (palette_bytes +
-                             (768 - len(palette_bytes)) * b'\x00')
-        m_im.putpalette(new_palette_bytes)
-        m_im.palette = ImagePalette.ImagePalette("RGB",
-                                               palette=palette_bytes,
-                                               size=len(palette_bytes))
-
+        m_im = im.remap_palette(used_palette_colors, source_palette)
+        palette_bytes = m_im.palette.palette
+        
         # oh gawd, this is modifying the image in place so I can pass by ref.
         # REFACTOR SOONEST
-        im.frombytes(m_im.tobytes())
-
-    if not palette_bytes:
+        im.im = m_im.im
+        im.palette = m_im.palette
+    else:
         palette_bytes = source_palette
 
     # returning palette, _not_ padded to 768 bytes like our internal ones.
diff --git a/PIL/Image.py b/PIL/Image.py
index a656209..eba4e6d 100644
--- a/PIL/Image.py
+++ b/PIL/Image.py
@@ -1516,6 +1516,83 @@ def putpixel(self, xy, value):
             return self.pyaccess.putpixel(xy, value)
         return self.im.putpixel(xy, value)
 
+    def remap_palette(self, dest_map, source_palette=None):
+        """
+        Rewrites the image to reorder the palette.
+        
+        :param dest_map: A list of indexes into the original palette.
+           e.g. [1,0] would swap a two item palette, and list(range(255))
+           is the identity transform.
+        :param source_palette: Bytes or None.
+        :returns:  An :py:class:`~PIL.Image.Image` object. 
+        
+        """
+        from . import ImagePalette
+        
+        if self.mode not in ("L", "P"):
+            raise ValueError("illegal image mode")
+
+        if source_palette is None:
+            if self.mode == "P":
+                source_palette = self.im.getpalette("RGB")[:768]
+            else:  # L-mode
+                source_palette = bytearray(i//3 for i in range(768))
+           
+
+        palette_bytes = b""
+        new_positions = [0]*256
+
+        # pick only the used colors from the palette
+        for i, oldPosition in enumerate(dest_map):
+            palette_bytes += source_palette[oldPosition*3:oldPosition*3+3]
+            new_positions[oldPosition] = i
+
+        # replace the palette color id of all pixel with the new id
+
+        # Palette images are [0..255], mapped through a 1 or 3
+        # byte/color map.  We need to remap the whole image
+        # from palette 1 to palette 2. New_positions is
+        # an array of indexes into palette 1.  Palette 2 is
+        # palette 1 with any holes removed.
+
+        # We're going to leverage the convert mechanism to use the
+        # C code to remap the image from palette 1 to palette 2,
+        # by forcing the source image into 'L' mode and adding a
+        # mapping 'L' mode palette, then converting back to 'L'
+        # sans palette thus converting the image bytes, then
+        # assigning the optimized RGB palette.
+
+        # perf reference, 9500x4000 gif, w/~135 colors
+        # 14 sec prepatch, 1 sec postpatch with optimization forced.
+
+        mapping_palette = bytearray(new_positions)
+
+        m_im = self.copy()
+        m_im.mode = 'P'
+
+        m_im.palette = ImagePalette.ImagePalette("RGB",
+                                                 palette=mapping_palette*3,
+                                                 size=768)
+        #possibly set palette dirty, then
+        #m_im.putpalette(mapping_palette, 'L')  # converts to 'P'
+        # or just force it.
+        # UNDONE -- this is part of the general issue with palettes
+        m_im.im.putpalette(*m_im.palette.getdata())
+
+        m_im = m_im.convert('L')
+
+        # Internally, we require 768 bytes for a palette.
+        new_palette_bytes = (palette_bytes +
+                             (768 - len(palette_bytes)) * b'\x00')
+        m_im.putpalette(new_palette_bytes)
+        m_im.palette = ImagePalette.ImagePalette("RGB",
+                                                 palette=palette_bytes,
+                                                 size=len(palette_bytes))
+
+        return m_im
+        
+        
+
     def resize(self, size, resample=NEAREST):
         """
         Returns a resized copy of this image.

From 1670aa043428f1759cbc5bc05912a766c8656029 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 06:14:04 -0800
Subject: [PATCH 15/26] Refactor get_palette to do one thing, and not mutate
 the image in place

---
 PIL/GifImagePlugin.py | 55 ++++++++++++++++++++++++++++++---------------------
 1 file changed, 33 insertions(+), 22 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index f774ace..b0cf8cf 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -312,6 +312,8 @@ def _write_single_frame(im, fp, palette):
     else:
         im_out = _convert_mode(im, True)
 
+    im_out = _normalize_palette(im_out, palette, im.encoderinfo)
+
     for s in _get_global_header(im_out, palette, im.encoderinfo):
         fp.write(s)
 
@@ -338,7 +340,8 @@ def _write_multiple_frames(im, fp, palette):
     for imSequence in [im]+im.encoderinfo.get("append_images", []):
         for im_frame in ImageSequence.Iterator(imSequence):
             im_frame = _convert_mode(im_frame)
-
+            im_frame = _normalize_palette(im_frame, palette, encoderinfo)
+            
             encoderinfo = im.encoderinfo.copy()
             if isinstance(duration, (list, tuple)):
                 encoderinfo['duration'] = duration[frame_count]
@@ -347,8 +350,12 @@ def _write_multiple_frames(im, fp, palette):
             if im_frames:
                 # delta frame
                 previous = im_frames[-1]
-                delta = ImageChops.subtract_modulo(im_frame,
-                                                   previous['im'])
+                if _get_palette_bytes(im_frame) == _get_palette_bytes(previous['im']):
+                    delta = ImageChops.subtract_modulo(im_frame,
+                                                       previous['im'])
+                else:
+                    delta = ImageChops.subtract_modulo(im_frame.convert('RGB'),
+                                                       previous['im'].convert('RGB'))
                 bbox = delta.getbbox()
                 if not bbox:
                     # This frame is identical to the previous frame
@@ -362,6 +369,7 @@ def _write_multiple_frames(im, fp, palette):
                 'bbox':bbox,
                 'encoderinfo':encoderinfo
             })
+            
     if len(im_frames) > 1:
         for frame_data in im_frames:
             im_frame = frame_data['im']
@@ -589,16 +597,17 @@ def _get_header_palette(palette_bytes):
         palette_bytes += o8(0) * 3 * actual_target_size_diff
     return palette_bytes
 
-def _get_palette_bytes(im, palette, info):
+def _normalize_palette(im, palette, info):
     """
-    Gets the palette for inclusion in the gif header, if optimization is
-    requested or required, the palette is rewritten and the image is
-    mutatated in place. 
-    
+    Normalizes the palette for image.
+      - Sets the palette to the incoming palette, if provided.
+      - Ensures that there's a palette for L mode images
+      - Optimizes the palette if necessary/desired.
+
     :param im: Image object
     :param palette: bytes object containing the source palette, or ....
     :param info: encoderinfo 
-    :returns: Bytes, len<=768 suitable for inclusion in gif header
+    :returns: Image object
     """
     if im.mode == "P":
         if palette and isinstance(palette, bytes):
@@ -610,23 +619,24 @@ def _get_palette_bytes(im, palette, info):
             source_palette = palette[:768]
         else:
             source_palette = bytearray(i//3 for i in range(768))
-
-    palette_bytes = None
+        im.palette = ImagePalette.ImagePalette("RGB",
+                                               palette=source_palette)
 
     used_palette_colors = _get_optimize(im, info)
     if used_palette_colors is not None:
-        m_im = im.remap_palette(used_palette_colors, source_palette)
-        palette_bytes = m_im.palette.palette
-        
-        # oh gawd, this is modifying the image in place so I can pass by ref.
-        # REFACTOR SOONEST
-        im.im = m_im.im
-        im.palette = m_im.palette
-    else:
-        palette_bytes = source_palette
+        return im.remap_palette(used_palette_colors, source_palette)
 
-    # returning palette, _not_ padded to 768 bytes like our internal ones.
-    return palette_bytes
+    im.palette.palette = source_palette
+    return im
+
+def _get_palette_bytes(im, *args):
+     """
+     Gets the palette for inclusion in the gif header
+
+     :param im: Image object
+     :returns: Bytes, len<=768 suitable for inclusion in gif header
+     """
+     return im.palette.palette
 
 def _get_global_header(im, palette, info):
     """Return a list of strings representing a GIF header"""
@@ -672,6 +682,7 @@ def getheader(im, palette=None, info=[]):
     if not "background" in info and "background" in im.info:
         info["background"] = im.info["background"]
 
+    im = _normalize_palette(im, palette, info)
     header = _get_global_header(im, palette, info)
 
     return header, used_palette_colors

From 47ee535d7e4a94bd24fc8c56d8e2e4f25d6e2c0e Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 06:57:10 -0800
Subject: [PATCH 16/26] Encoderinfo fix

---
 PIL/GifImagePlugin.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index b0cf8cf..56bf2cd 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -340,7 +340,7 @@ def _write_multiple_frames(im, fp, palette):
     for imSequence in [im]+im.encoderinfo.get("append_images", []):
         for im_frame in ImageSequence.Iterator(imSequence):
             im_frame = _convert_mode(im_frame)
-            im_frame = _normalize_palette(im_frame, palette, encoderinfo)
+            im_frame = _normalize_palette(im_frame, palette, im.encoderinfo)
             
             encoderinfo = im.encoderinfo.copy()
             if isinstance(duration, (list, tuple)):

From 951e628aaa0b3b503f561b0f1a99364c12ec2f72 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 06:58:37 -0800
Subject: [PATCH 17/26] merge failure

---
 PIL/GifImagePlugin.py | 16 ++++++----------
 1 file changed, 6 insertions(+), 10 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 56bf2cd..77f844c 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -293,25 +293,21 @@ def load_end(self):
 }
 
 
-def _convert_mode(im, initial_call=False):
-    # convert on the fly (EXPERIMENTAL -- I'm not sure PIL
-    # should automatically convert images on save...)
+def _normalize_mode(im, initial_call=False):
+    if im.mode in RAWMODE:
+        return im
     if Image.getmodebase(im.mode) == "RGB":
         if initial_call:
             palette_size = 256
             if im.palette:
                 palette_size = len(im.palette.getdata()[1]) // 3
-            return im.convert("P", palette=1, colors=palette_size)
+            return im.convert("P", palette=Image.ADAPTIVE, colors=palette_size)
         else:
             return im.convert("P")
     return im.convert("L")
 
 def _write_single_frame(im, fp, palette):
-    if im.mode in RAWMODE:
-        im_out = im.copy()
-    else:
-        im_out = _convert_mode(im, True)
-
+    im_out = _normalize_mode(im, True)
     im_out = _normalize_palette(im_out, palette, im.encoderinfo)
 
     for s in _get_global_header(im_out, palette, im.encoderinfo):
@@ -339,7 +335,7 @@ def _write_multiple_frames(im, fp, palette):
     frame_count = 0
     for imSequence in [im]+im.encoderinfo.get("append_images", []):
         for im_frame in ImageSequence.Iterator(imSequence):
-            im_frame = _convert_mode(im_frame)
+            im_frame = _normalize_mode(im_frame)
             im_frame = _normalize_palette(im_frame, palette, im.encoderinfo)
             
             encoderinfo = im.encoderinfo.copy()

From 9c40327d2eb742cfa0a1fbf3b6f20db17cfbda4f Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 07:37:14 -0800
Subject: [PATCH 18/26] Don't requantize 'P' images

---
 PIL/GifImagePlugin.py | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 77f844c..fceb13e 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -295,6 +295,7 @@ def load_end(self):
 
 def _normalize_mode(im, initial_call=False):
     if im.mode in RAWMODE:
+        im.load()
         return im
     if Image.getmodebase(im.mode) == "RGB":
         if initial_call:
@@ -326,16 +327,15 @@ def _write_single_frame(im, fp, palette):
     fp.write(b"\0")  # end of image data
 
 def _write_multiple_frames(im, fp, palette):
-    if "duration" in im.encoderinfo:
-        duration = im.encoderinfo["duration"]
-    else:
-        duration = None
+
+    duration = im.encoderinfo.get("duration", None)
 
     im_frames = []
     frame_count = 0
     for imSequence in [im]+im.encoderinfo.get("append_images", []):
         for im_frame in ImageSequence.Iterator(imSequence):
-            im_frame = _normalize_mode(im_frame)
+            # a copy is required here since seek can still mutate the image
+            im_frame = _normalize_mode(im_frame.copy())
             im_frame = _normalize_palette(im_frame, palette, im.encoderinfo)
             
             encoderinfo = im.encoderinfo.copy()

From 57d7590ada6a2c304830ab5b5d1456868ce492c6 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 07:38:46 -0800
Subject: [PATCH 19/26] removed extra params from _get_palette_bytes

---
 PIL/GifImagePlugin.py | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index fceb13e..44129b7 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -337,7 +337,7 @@ def _write_multiple_frames(im, fp, palette):
             # a copy is required here since seek can still mutate the image
             im_frame = _normalize_mode(im_frame.copy())
             im_frame = _normalize_palette(im_frame, palette, im.encoderinfo)
-            
+
             encoderinfo = im.encoderinfo.copy()
             if isinstance(duration, (list, tuple)):
                 encoderinfo['duration'] = duration[frame_count]
@@ -365,7 +365,7 @@ def _write_multiple_frames(im, fp, palette):
                 'bbox':bbox,
                 'encoderinfo':encoderinfo
             })
-            
+
     if len(im_frames) > 1:
         for frame_data in im_frames:
             im_frame = frame_data['im']
@@ -472,7 +472,7 @@ def _get_local_header(fp, im, offset, flags):
     include_color_table = im.encoderinfo.get('include_color_table')
     if include_color_table:
         palette = im.encoderinfo.get("palette", None)
-        palette_bytes = _get_palette_bytes(im, palette, im.encoderinfo)
+        palette_bytes = _get_palette_bytes(im)
         color_table_size = _get_color_table_size(palette_bytes)
         if color_table_size:
             flags = flags | 128               # local color table flag
@@ -544,12 +544,12 @@ def _save_netpbm(im, fp, filename):
 def _get_optimize(im, info):
     """
     Palette optimization is a potentially expensive operation.
-    
+
     This function determines if the palette should be optimized using
     some heuristics, then returns the list of palette entries in use.
-    
+
     :param im: Image object
-    :param info: encoderinfo 
+    :param info: encoderinfo
     :returns: list of indexes of palette entries in use, or None
     """
     if im.mode in ("P", "L") and info and info.get("optimize", 0):
@@ -602,7 +602,7 @@ def _normalize_palette(im, palette, info):
 
     :param im: Image object
     :param palette: bytes object containing the source palette, or ....
-    :param info: encoderinfo 
+    :param info: encoderinfo
     :returns: Image object
     """
     if im.mode == "P":
@@ -625,7 +625,7 @@ def _normalize_palette(im, palette, info):
     im.palette.palette = source_palette
     return im
 
-def _get_palette_bytes(im, *args):
+def _get_palette_bytes(im):
      """
      Gets the palette for inclusion in the gif header
 
@@ -652,7 +652,7 @@ def _get_global_header(im, palette, info):
         if im.info.get("version") == b"89a":
             version = b"89a"
 
-    palette_bytes = _get_palette_bytes(im, palette, info)
+    palette_bytes = _get_palette_bytes(im)
     color_table_size = _get_color_table_size(palette_bytes)
 
     background = info["background"] if "background" in info else 0

From 8acb8c904b84caed74f4f44dcf3c7c323aa8a4a5 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 07:41:42 -0800
Subject: [PATCH 20/26] removed extra param from _get_global_header

---
 PIL/GifImagePlugin.py | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 44129b7..3711a15 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -311,7 +311,7 @@ def _write_single_frame(im, fp, palette):
     im_out = _normalize_mode(im, True)
     im_out = _normalize_palette(im_out, palette, im.encoderinfo)
 
-    for s in _get_global_header(im_out, palette, im.encoderinfo):
+    for s in _get_global_header(im_out, im.encoderinfo):
         fp.write(s)
 
     # local image header
@@ -371,7 +371,7 @@ def _write_multiple_frames(im, fp, palette):
             im_frame = frame_data['im']
             if not frame_data['bbox']:
                 # global header
-                for s in _get_global_header(im_frame, palette,
+                for s in _get_global_header(im_frame,
                                             frame_data['encoderinfo']):
                     fp.write(s)
                 offset = (0, 0)
@@ -634,7 +634,7 @@ def _get_palette_bytes(im):
      """
      return im.palette.palette
 
-def _get_global_header(im, palette, info):
+def _get_global_header(im, info):
     """Return a list of strings representing a GIF header"""
 
     # Header Block
@@ -679,7 +679,7 @@ def getheader(im, palette=None, info=[]):
         info["background"] = im.info["background"]
 
     im = _normalize_palette(im, palette, info)
-    header = _get_global_header(im, palette, info)
+    header = _get_global_header(im, info)
 
     return header, used_palette_colors
 

From 480e819992248fa8628661166ccf74bce7fe55b7 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 07:58:30 -0800
Subject: [PATCH 21/26] Docstring Comments on methods

---
 PIL/GifImagePlugin.py | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 3711a15..868ceb0 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -584,6 +584,13 @@ def _get_color_table_size(palette_bytes):
     return color_table_size
 
 def _get_header_palette(palette_bytes):
+    """
+    Returns the palette, null padded to the next power of 2 (*3) bytes
+    suitable for direct inclusion in the GIF header
+
+    :param palette_bytes: Unpadded palette bytes, in RGBRGB form
+    :returns: Null padded palette
+    """
     color_table_size = _get_color_table_size(palette_bytes)
 
     # add the missing amount of bytes
@@ -673,6 +680,17 @@ def _get_global_header(im, info):
     ]
 
 def getheader(im, palette=None, info=[]):
+    """
+    Legacy Method to get Gif data from image.
+
+    Warning:: May modify image data.
+
+    :param im: Image object
+    :param palette: bytes object containing the source palette, or ....
+    :param info: encoderinfo 
+    :returns: tuple of(list of header items, optimized palette)
+
+    """
     used_palette_colors = _get_optimize(im, info)
 
     if not "background" in info and "background" in im.info:

From 39e176348ea9f7cf5d378fd058d6cb93de477778 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Thu, 23 Feb 2017 07:59:06 -0800
Subject: [PATCH 22/26] legacy getheader mutates the image

---
 PIL/GifImagePlugin.py | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 868ceb0..34a87e3 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -696,7 +696,9 @@ def getheader(im, palette=None, info=[]):
     if not "background" in info and "background" in im.info:
         info["background"] = im.info["background"]
 
-    im = _normalize_palette(im, palette, info)
+    im_mod = _normalize_palette(im, palette, info)
+    im.palette = im_mod.palette
+    im.im = im_mod.im
     header = _get_global_header(im, info)
 
     return header, used_palette_colors

From 162bbd6a798bd5159e41e5e7b4d39196e6a6643c Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Thu, 26 Jan 2017 19:39:59 +1100
Subject: [PATCH 23/26] Test from #2375,
 0ebb4cd1c0f9aa5d79c5814f9f1f1c3243ffeb1f

---
 Tests/test_file_gif.py | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/Tests/test_file_gif.py b/Tests/test_file_gif.py
index 5db3820..e610bcc 100644
--- a/Tests/test_file_gif.py
+++ b/Tests/test_file_gif.py
@@ -424,10 +424,10 @@ def test_append_images(self):
 
     def test_transparent_optimize(self):
         # from issue #2195, if the transparent color is incorrectly
-        # optimized out, gif loses transparency Need a palette that
-        # isn't using the 0 color, and one that's > 128 items where
-        # the transparent color is actually the top palette entry to
-        # trigger the bug.
+        # optimized out, gif loses transparency
+        # Need a palette that isn't using the 0 color, and one
+        # that's > 128 items where the transparent color is actually
+        # the top palette entry to trigger the bug.
 
         from PIL import ImagePalette
 
@@ -444,6 +444,16 @@ def test_transparent_optimize(self):
 
         self.assertEqual(reloaded.info['transparency'], 253)
 
+    def test_bbox(self):
+        out = self.tempfile('temp.gif')
+
+        im = Image.new('RGB', (100,100), '#fff')
+        ims = [Image.new("RGB", (100,100), '#000')]
+        im.save(out, save_all=True, append_images=ims)
+
+        reread = Image.open(out)
+        self.assertEqual(reread.n_frames, 2)
+
 
 if __name__ == '__main__':
     unittest.main()

From 8436f41f09365626b0f463a16df3e88c0adcf359 Mon Sep 17 00:00:00 2001
From: Andrew Murray <radarhere@gmail.com>
Date: Sat, 25 Feb 2017 13:50:49 +1100
Subject: [PATCH 24/26] Added comment that getdata is legacy

---
 PIL/GifImagePlugin.py | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index 34a87e3..f7d16ef 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -720,10 +720,14 @@ def _write_frame_data(fp, im_frame, offset, params):
 # To specify duration, add the time in milliseconds to getdata(),
 # e.g. getdata(im_frame, duration=1000)
 def getdata(im, offset=(0, 0), **params):
-    """Return a list of strings representing this image.
-       The first string is a local image header, the rest contains
-       encoded image data."""
+    """
+    Legacy Method
+
+    Return a list of strings representing this image.
+    The first string is a local image header, the rest contains
+    encoded image data.
 
+    """
     class Collector(object):
         data = []
 

From e8414876fafd4d23249e638a9ece7f9800a17fa1 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Sat, 25 Feb 2017 02:24:53 -0800
Subject: [PATCH 25/26] Renamed _get_local_header to _write_local_header

---
 PIL/GifImagePlugin.py | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index f7d16ef..e0b6674 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -318,7 +318,7 @@ def _write_single_frame(im, fp, palette):
     flags = 0
     if get_interlace(im):
         flags = flags | 64
-    _get_local_header(fp, im, (0, 0), flags)
+    _write_local_header(fp, im, (0, 0), flags)
 
     im_out.encoderconfig = (8, get_interlace(im))
     ImageFile._save(im_out, fp, [("gif", (0, 0)+im.size, 0,
@@ -417,7 +417,7 @@ def get_interlace(im):
     return interlace
 
 
-def _get_local_header(fp, im, offset, flags):
+def _write_local_header(fp, im, offset, flags):
     transparent_color_exists = False
     try:
         transparency = im.encoderinfo["transparency"]
@@ -708,7 +708,7 @@ def _write_frame_data(fp, im_frame, offset, params):
         im_frame.encoderinfo = params
 
         # local image header
-        _get_local_header(fp, im_frame, offset, 0)
+        _write_local_header(fp, im_frame, offset, 0)
 
         ImageFile._save(im_frame, fp, [("gif", (0, 0)+im_frame.size, 0,
                                         RAWMODE[im_frame.mode])])

From 91a2e6c6ca95064485908d35890cdb8d9a20e0f3 Mon Sep 17 00:00:00 2001
From: wiredfool <eric-github@soroos.net>
Date: Sat, 25 Feb 2017 02:29:54 -0800
Subject: [PATCH 26/26] Regroup methods, add docstring comments

---
 PIL/GifImagePlugin.py | 39 ++++++++++++++++++++++-----------------
 1 file changed, 22 insertions(+), 17 deletions(-)

diff --git a/PIL/GifImagePlugin.py b/PIL/GifImagePlugin.py
index e0b6674..30bc0ee 100644
--- a/PIL/GifImagePlugin.py
+++ b/PIL/GifImagePlugin.py
@@ -534,9 +534,6 @@ def _save_netpbm(im, fp, filename):
         pass
 
 
-# --------------------------------------------------------------------
-# GIF utilities
-
 # Force optimization so that we can test performance against
 # cases where it took lots of memory and time previously.
 _FORCE_OPTIMIZE = False
@@ -679,6 +676,23 @@ def _get_global_header(im, info):
         _get_header_palette(palette_bytes)
     ]
 
+def _write_frame_data(fp, im_frame, offset, params):
+    try:
+        im_frame.encoderinfo = params
+
+        # local image header
+        _write_local_header(fp, im_frame, offset, 0)
+
+        ImageFile._save(im_frame, fp, [("gif", (0, 0)+im_frame.size, 0,
+                                        RAWMODE[im_frame.mode])])
+
+        fp.write(b"\0")  # end of image data
+    finally:
+        del im_frame.encoderinfo
+
+# --------------------------------------------------------------------
+# Legacy GIF utilities
+
 def getheader(im, palette=None, info=[]):
     """
     Legacy Method to get Gif data from image.
@@ -703,20 +717,6 @@ def getheader(im, palette=None, info=[]):
 
     return header, used_palette_colors
 
-def _write_frame_data(fp, im_frame, offset, params):
-    try:
-        im_frame.encoderinfo = params
-
-        # local image header
-        _write_local_header(fp, im_frame, offset, 0)
-
-        ImageFile._save(im_frame, fp, [("gif", (0, 0)+im_frame.size, 0,
-                                        RAWMODE[im_frame.mode])])
-
-        fp.write(b"\0")  # end of image data
-    finally:
-        del im_frame.encoderinfo
-
 # To specify duration, add the time in milliseconds to getdata(),
 # e.g. getdata(im_frame, duration=1000)
 def getdata(im, offset=(0, 0), **params):
@@ -727,6 +727,11 @@ def getdata(im, offset=(0, 0), **params):
     The first string is a local image header, the rest contains
     encoded image data.
 
+    :param im: Image object
+    :param offset: Tuple of (x, y) pixels. Defaults to (0,0)
+    :param **params: E.g. duration or other encoder info parameters
+    :returns: List of Bytes containing gif encoded frame data
+
     """
     class Collector(object):
         data = []
